package net.cafestube;
import io.github.classgraph.ClassGraph;
import io.github.classgraph.ClassInfo;
import io.github.classgraph.ScanResult;
import net.minecraft.SharedConstants;
import net.minecraft.server.Bootstrap;

import java.io.File;
import java.io.FileWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.*;

public class EntityDataAccessorsCodegen {

    private static final String TARGET_PACKAGE = "net.cafestube.wiretapper.entity";
    private static final String OUTPUT_DIR = "src/main/java/net/cafestube/wiretapper/entity/";
    private static final String OUTPUT_FILENAME = "EntityDataAccessors.java";
    private static final String ENTITY_PACKAGE = "net.minecraft.world.entity";

    public static void main(String[] args) throws Exception {
        SharedConstants.tryDetectVersion();
        Bootstrap.bootStrap();
        Bootstrap.validate();

        Map<String, EntityInfo> entities = new LinkedHashMap<>();

        try (ScanResult scan = new ClassGraph()
                .acceptPackages(ENTITY_PACKAGE)
                .enableAllInfo()
                .scan()) {

            List<ClassInfo> classInfos = scan.getAllClasses().stream()
                    .filter(ci -> ci.getPackageName().startsWith(ENTITY_PACKAGE))
                    .toList();

            for (ClassInfo ci : classInfos) {
                try {
                    Class<?> clazz = Class.forName(ci.getName());

                    Field[] fields = clazz.getDeclaredFields();
                    List<FieldInfo> accessorFields = new ArrayList<>();
                    for (Field f : fields) {
                        String typeSimple = f.getType().getSimpleName();
                        if (typeSimple.endsWith("EntityDataAccessor") && Modifier.isStatic(f.getModifiers()))  {
                            accessorFields.add(new FieldInfo(f.getName(), f.getGenericType()));
                        }
                    }

                    if (!accessorFields.isEmpty()) {
                        EntityInfo ei = new EntityInfo(
                            clazz.getName(),
                            clazz.getSimpleName(),
                            clazz.getPackage() != null ? clazz.getPackage().getName() : "",
                            findSuperclassWithAccessors(clazz.getSuperclass()),
                            accessorFields
                        );
                        entities.put(ei.className, ei);
                        System.out.println("Found entity: " + ei.className + " (fields: " + accessorFields + ")");
                    }
                } catch (ClassNotFoundException ignored) {}
            }
        }

        if (entities.isEmpty()) {
            System.out.println("No EntityDataAccessor fields found. Make sure Minecraft classes are on the classpath.");
            return;
        }

        Map<String, List<EntityInfo>> children = new HashMap<>();
        for (EntityInfo ei : entities.values()) {
            if (ei.superName != null && entities.containsKey(ei.superName)) {
                children.computeIfAbsent(ei.superName, k -> new ArrayList<>()).add(ei);
            } else {
                children.computeIfAbsent("ROOT", k -> new ArrayList<>()).add(ei);
            }
        }

        File outDir = new File(OUTPUT_DIR);
        outDir.mkdirs();
        File outFile = new File(outDir, OUTPUT_FILENAME);

        try (FileWriter w = new FileWriter(outFile)) {
            w.write("package " + TARGET_PACKAGE + ";\n\n");
            w.write("import java.lang.reflect.Field;\n\n");
            w.write("/**\n");
            w.write(" * This class is auto-generated by EntityDataAccessorsCodegen.\n");
            w.write(" * Do not modify this file directly. Instead, modify and run the codegen tool.\n");
            w.write(" * <p>\n");
            w.write(" * Generated Entity Data Accessors for Minecraft version: " + SharedConstants.getCurrentVersion().name() + "\n");
            w.write(" */\n");
            w.write("@SuppressWarnings(\"unused\")\n");
            w.write("public final class EntityDataAccessors {\n\n");

            w.write("    @SuppressWarnings(\"unchecked\")\n");
            w.write("    private static <T> T resolve(Class<?> owner, String fieldName) {\n");
            w.write("        try {\n");
            w.write("            Field f = owner.getDeclaredField(fieldName);\n");
            w.write("            f.setAccessible(true);\n");
            w.write("            return (T) f.get(null);\n");
            w.write("        } catch (Throwable t) {\n");
            w.write("            System.err.println(\"Warning: failed to resolve '\" + owner.getName() + \".\" + \"' -> \" + t);\n");
            w.write("            return null;\n");
            w.write("        }\n");
            w.write("    }\n\n");

            for (EntityInfo ei : children.getOrDefault("ROOT", Collections.emptyList())) {
                writeEntityClass(w, ei, entities, children, 1);
            }

            w.write("}\n");
        }

        System.out.println("Generated: " + outFile.getAbsolutePath());
    }

    private static String findSuperclassWithAccessors(Class<?> superclass) {
        if(superclass == null) return null;


        while (superclass != null && superclass != Object.class) {
            Field[] fields = superclass.getDeclaredFields();

            for (Field f : fields) {
                String typeSimple = f.getType().getSimpleName();
                if (typeSimple.endsWith("EntityDataAccessor") && Modifier.isStatic(f.getModifiers())) {
                    return superclass.getName();
                }
            }

            superclass = superclass.getSuperclass();
        }

        return null;
    }

    private static void writeEntityClass(FileWriter w, EntityInfo ei, Map<String, EntityInfo> allEntities,
                                         Map<String, List<EntityInfo>> children, int indent) throws Exception {
        String indentStr = "    ".repeat(indent);
        String nestedName = ei.simpleName;
        String extendsClause = "";
        if (ei.superName != null && allEntities.containsKey(ei.superName)) {
            String parentSimple = allEntities.get(ei.superName).simpleName;
            extendsClause = " extends " + parentSimple;
        }

        w.write(indentStr + "public static class " + nestedName + extendsClause + " {\n");

        for (FieldInfo field : ei.fields) {
            w.write(indentStr + "    public static final " + field.genericType.getTypeName().replace("$", ".") + " " + field.name + " = " +
                    "resolve(" + ei.className.replace("$", ".") + ".class, \"" + field.name + "\");\n");
        }

        w.write(indentStr + "}\n\n");

        List<EntityInfo> kids = children.getOrDefault(ei.className, Collections.emptyList());
        if (!kids.isEmpty()) {
            w.write("\n");
            for (EntityInfo kid : kids) {
                writeEntityClass(w, kid, allEntities, children, indent);
            }
        }
    }

    record EntityInfo(
        String className,
        String simpleName,
        String packageName,
        String superName,
        List<FieldInfo> fields
    ) {}

    record FieldInfo(String name, Type genericType) {}
}
